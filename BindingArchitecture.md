# Общие принципы #
  * Все C++-классы, экспортируемые в Lua, должны исправно и самостоятельно работать в C++ (на случай отказа от Lua или замены ее на другой язык).
  * Для каждого экспортируемого класса SomeClass создается открытый наследник с именем LuaSomeClass. В нем прописываются некоторые специфичные для Lua свойства, поля и методы (см. LuaScreenItem). Этот клас описыавется либо в той же паре .h+.cpp файлов, либо в отдельной, если класс получился достаточно большой.
  * Если исходные C++-классы соединены отношением наследования, то их Lua- потомки также наследуют друг друга. Это может привести к проблеме виртуального наследования (см. LuaScreenItem).
  * В классе LuaSomeClass создается статический метод luabind(lua\_State`*` L), который, собственно, осуществляет регистрацию в Lua данного класса. Биндинг осуществляется как тут: http://www.rasterbar.com/products/luabind/docs.html#binding-classes-to-lua . Методы luabind() из всех Lua-классов вызываются в функции App::Init() при старте программы (см. App.cpp).


# Какие файлы смотреть #
  * ScreenItem.h/ScreenItem.cpp содержат классы ScreenItem, SimpleItem и CompositeItem.
  * LuaScreenItem.h/LuaScreenItem.cpp содержит соответствующие всем трем видам ScreenItem'ов Lua-классы и их методы luabind (см.!)
  * Image.h/Image.cpp, Animation.h/Animation.cpp, Texture.h/Texture.cpp содержат соответствующие "View-" классы и их Lua-варианты. Все они наследуются от Proton'овского класса EntityComponent (зачастую косвенно). Эти классы могут быть переданы в метод setView() класса SimpleItem (чтобы назначить тому внешний вид).
  * Timer.h/Timer.cpp, LuaTimer.h/LuaTimer.cpp - то же для класса Timer. Класс LuaTimer интересен тем, что для хранения ссылки на callback-функцию (которая будет вызываться при срабатывании таймера) использует класс luabind::object, а также экспортирует это поле в Lua и умеет вызывать его как функцию.
  * Text.h/Text.cpp - реализует все классы, связанные с отображением текста: Text и TextBox (а также LuaText и LuaTextBox).

# LuaScreenItem #
Так как все, что мы видим на экране - это разновидности ScreenItem'ов, рассмотрим иерархию классов-наследников ScreenItem'а более подробно. См. рисунок.

![https://dialog-quest.googlecode.com/svn/wiki/classes_lua.png](https://dialog-quest.googlecode.com/svn/wiki/classes_lua.png)

Как видим, на рисунке:
  * ScreenItem и две его разновидности - SimpleItem и CompositeItem - образуют иерархию "штаны".
  * К этм "штанам" подключается еще одна точно такая же иерархия из LuaScreenItem и его потомков.
  * В результате возникает ситуация множественного наследования (ScreenItem наследуется в LuaSimpleItem и LuaCompositeItem двумя путями). Поэтому на уровне непосредственных наслеников ScreenItem'а применено [виртуальное наследование](http://habrahabr.ru/post/185826/).

**Также важно** отметить, что необхдоимость вынесения класса LuaScreenItem и его наследников в отдельный файл вызвана их нетривиальным внутренним устройством. Этот класс реализует возможность "навешивания" на события пользовательского ввода Lua-функции-обработчики. См. поля этого класса:
  * onDragStart\_cb, onDragEnd\_cb, onDrag\_cb, onDbClick\_cb
  * onChar\_cb, onFocusLose\_cb.
А также **соответствующие им методы!**

# Другое #
  * В методе luabind класса LuaCompositeItem в Lua-машину добавляется глобальная переменная под именем root - корень дерева всех экранных элементов. См. функцию root\_item() в LuaScreenItem.cpp.
  * В файле lua\_lib.cpp описаны несколько экспортируемых в Lua свободных функций и переменных: screen\_width, screen\_height, rand() и др.