#summary Краткое описание языка программирования Lua

==Шпаргалка по языку Lua==
===Переменные и вообще основы===
Переменные создаются автоматически в момент их первого использования:
{{{
x = 5
s = "Hello, world"
}}}
Тип переменной не фиксируется и может быть изменен в любой момент (однако, хранить в одной переменной в разное время разные по смыслу значения — дурной тон!):
{{{
v = 5
v = "Hello"	-- теперь v – это строка
}}}

"Строки-комментарии" обозначаются двумя знаками "минус" ("--").

Распечатать что-либо на консоли можно при помощи функции "print()". "Склеить" при этом несколько строк в одну можно при помощи специального оператора ".." (символ конца строки добавляется автоматически):
{{{
print(x)					--> 5
print(s)					--> Hello, world
print("x="..x.." s="..s)	--> x=5 s=Hello, world
}}}

*Узнать длину* строки можно при помощи оператора "#". А используя запятую (",") можно вывести на экран несколько полей, разделяя их {{{<}}}tab{{{>'}}}ами:
{{{
s = "hello"
len = #s
print(s, len)	--> hello    5
}}}

Все переменные в Lua делятся на "глобальные" и "локальные". Глобальные переменные доступны во всех функциях, всех файлах и вообще всех фрагментах кода, выполняемых в данном процессе интерпретатора. Все переменные в примерах выше — глобальные.

"Локальная" переменная создается при помощи ключевого слова local:
{{{
n = 10		-- глобальная n
local n = 9	-- локальная n (перекрывает[1] глобальную)
}}}

{{{[1]}}}Вследствие совпадения имен, локальная n "заслоняет" собой глобальную n. В результате этого, код в данном блоке при обращении к переменной с именем n "попадает" на локальную n и к глобальной переменной с тем же именем доступа не имеет. После завершения блока локальная n уничтожается, а глобальная остается (со своим первоначальным значением) и становится доступной.

Область видимости локальных переменных ограничена текущей функцией, текущим блоком (do-end, then-else-end и др.), текущим файлом  или текущей "порцией" кода. *Не используйте глобальные переменные там, где достаточно локальных!*

И пример из руководства по Lua:
{{{
x = 10          	      -- глобальная переменная x
do                  		-- начало блока
	local x = x           -- объявление локальной переменной
	print(x)              --> 10
	x = x+1
	do                    -- начало вложенного блока
		local x = x+1 -- другая локальная "x"
		print(x)      --> 12
	end
	print(x)              --> 11
end
print(x)  	              --> 10  (глобальная переменная)
}}}

===Типы данных и таблицы===
Язык Lua поддерживает 8 типов данных.
Обратите внимание: названия типов не являются ключевыми словами языка (их не надо писать в программах!):
 # "nil" — неопределенный, "пустой" тип;
 # "boolean" — логический: true или false;
 # "number" — числовой (на самом деле это double);
 # "string" — строка (последовательность байтов);
 # "table" — таблица;
 # "function" — функция;
 # "userdata" — пользовательские данные;
 # "thread" — поток (приведен в этом списке для полноты картины).

К "традиционным" типам относятся boolean, number и string. Number может хранить как целые числа, так и числа с плавающей точкой. String, в отличие от Си-шных строк — это просто последовательность байтов: она не обязана заканчиваться нулевым байтом и, как следствие, может содержать любое количество нулевых байтов внутри себя.

Переменная типа "nil" может содержать только одно значение — nil. *Используется для указания на то, что переменная не содержит никакого значения*:
{{{
local tea, coffee, dance = true, false, true
print(tea, coffee, dance)		   --> true    false   true
dance = nil
print(tea, coffee, dance)    		   --> true    false   nil
print(type(tea), type(coffee), type(dance))--> boolean boolean nil
}}}
(системная функция *type()* возвращает строку, содержащую наименование типа заданной переменной)

Особенностью Lua является тип *table*, выполняющий роль *массивов и ассоциативных контейнеров* ("словарей"). Table (таблица) — это множество пар вида: "ключ, значение". Например:
|| *Ключ* || *Значение* ||
||1		|| "Купить молока"||
||2		|| "Позвонить Васе"||
||3		|| "Спасти мир"||

|| *Ключ* || *Значение* ||
|| "Иванов"|| "555-12-41" || 
|| "Петров"|| "777-34-52" || 
|| "Сидоров"||"334-02-78" || 


Обращение к записям таблицы, как видим, производится по ключу. Ключ при этом может быть указан как в скобках (t["me"]) так и через точку (t.me). При этом вариант со скобками (внимание!) предоставлят очень важную возможность — *возможность косвенного обращения* (когда конкретное значение ключа определяется на этапе выполнения программы и во время ее написания неизвестно). При косвенном обращении значение ключа берется из переменной (а не задается прямо в тексте программы):
{{{
local t = make_some_table()
local key = get_key_from_user()
local val = t[key]		-- !!! косвенное обращение
print("Your choice "..key.." is "..val)
}}}
При отсутствии косвенного обращения таблицы Lua ничем бы не отличались от Си-шных структур (struct). А при его наличии — они объединяют в себе возможности структур (и классов!), массивов и ассоциативных массивов.

В качестве ключей и значений в строках таблицы могут использоваться значения *любых типов*, кроме nil — *в том числе функций и таблиц* (можно сделать таблицу фукций и таблицу таблиц).

К таблицам, индексируемым целыми числами, применима операция получения длины ("#"). Она возвращает номер последнего элемента:
{{{
local t = {1, 2, 3, 4}
print(#t)		--> 4
}}}

Тип "function" — это ссылка на функцию (см. часть 5 "Функции").

*Внимание! Важное отличие типов table, function, userdata и thread от всех остальных!*
Переменные этих типов не хранят в себе "значение" соответствующей сущности (например, таблицы), а хранят лишь "ссылку" на эту сущность (переменные типа nil, number, boolean и string хранят *само значение*). Из этого следует, что:
 # При сравнении таких переменных сравниваются не *значения*, а *ссылки* (т.е. равенство ("==") возможно только тогда, когда обе сравниваемые переменные ссылаются на один и тот же объект).
 # Операция присваивания (=) не заменяет одну таблицу другой, а лишь дублирует ссылку на одну и ту же таблицу (которая стоит справа от знака "="). В результате — все последующие изменения этой таблицы видны через обе переменные-ссылки.

Пример:
{{{
local m = {"Mars"}	-- массив длиной 1
local mm = {"Mars"}	-- массив длиной 1
print( m == mm )	--> false (ссылки не равны, это разные объекты!)
local v = m		-- дублировать ссылку!
print( m[1] )		--> Mars
print( v[1] )		--> Mars
print( v == m )		--> true (ссылки равны)
v[1] = "Venus"		-- изменить объект (не ссылку!)
print( v[1] )		--> Venus (как и ожидалось)
print( m[1] )		--> Venus (нежданчик!)
}}}

===Операции и выражения===
====Арифметические операции====
{{{
local x = 3
local y = 5
local sum = x + y		-- сложение
local mul = x * y		-- умножение
local div = x / y		-- деление
local sub = x – y		-- вычитание
local pow = x^y			-- возведение в степень
x = - y				-- унарный минус (инверсия знака)
local mod = x % y		-- остаток от деления
}}}

Возведение в степень ("{{{^}}}") и взятие остатка от деления ("%") поддерживается для произвольных вещественных чисел (а не только для целых). Например, x{{{^}}}(0.5) —  извлечение квадратного корня.

*Важная особенность: если один из аргументов арифметической операции имеет тип string и содержит строку, которая может быть преобразована в число — то это преобразование производится ''автоматически'' и арифметическая операция выполняется успешно.*

====Операции сравнения====
Lua поддерживает следующие операции сравнения:
{{{
local x = 3
local y = 5
local  eq = (x == y)		-- (false) сравнение на равенство
local neq = (x ~= y)		-- (true)  наоборот: "не равно"
local   g = (x >  y)		-- (false) x больше y?
local  ge = (x >= y)		-- (false) x больше y или равен y?
local   l = (x <  y)		-- (true)  x меньше y?
local  le = (x <= y)		-- (true)  x меньше y или равен y?
}}}

Операции сравнения возвращают тип boolean. В результате выполнения этого примера переменные, стоящие слева от знаков "=", получат соответствующие булевские значения (которые указаны в скобках в комментариях справа).

В случае если x и y — не числа, а ''строки'', будет производиться их ''лексикографическое'' сравнение. Если x — число, а y — строка, которая может быть преобразована в число, автоматического преобразования "не происходит": 0=="0" вернет false.

Если x и y — ссылки (т.е. имеют тип table, function, userdata или thread) то 
операции "==" и "{{{~}}}=" будут сравнивать ''ссылки'', а не объекты, на которые они ссылаются: выражение p==q возвращает true тогда и только тогда, когда p и q ссылаются на один и тот же объект.

====Логические операции====
Для конструирования сложных условий в операторах if, while и других используются "логические операции" and, or и not. Они применяются к булевским значениям (например, к результатам работы операций сравнения) и возвращают также булевское значение:
{{{
local a, b, c = 1, 2, 3
local a_is_max = (a >= b and a >= c)			-- пример and
local have_2_equal = (a==b or b==c or a==c)		-- пример or
local not_have_2_equal = not (a==b or b==c or a==c)	-- пример not
}}}

Более точно: операция or возвращает свой первый аргумент, если он не равен false или nil. В противном случае она возвращает второй аргумент. Операция and возвращает свой второй аргумент, если оба они не равны false или nil, в противном случае возвращается false (nil or "hello" вернет "hello").

В сложных выражениях с неоднозначной расстановкой скобок сначала выполняется not, затем and и позже всех — or:
{{{
local res = not a or b and c	-- эквивалентно (not a) or (b and c)
}}}

В общем же случае "приоритеты операций" таковы:
 * or
 * and
 * {{{<}}}     >     {{{<}}}=    >=    {{{~}}}=    ==
 * ..
 * +     -
 * *     /     %
 * not   #     - (унарный)
 * {{{^}}}

 ===Операторы передачи управления===
====Оператор if====
{{{
---- simple if ----
if x == a then
	-- операторы, которые будут
	-- выполняться, если x == a
end

---- if-else ----
if x == a then
	-- операторы, которые будут
	-- выполняться, если x == a
else
	-- операторы, которые будут
	-- выполняться в противном случае
end

---- if-elseif-else ----
if x == a then
	-- операторы, которые будут
	-- выполняться, если x == a
elseif x == b then
	-- операторы, которые будут
	-- выполняться, если x ~= a and x == b
else
	-- операторы, которые будут
	-- выполняться в противном случае
end
}}}

====Цикл с пред-условием (while)====
{{{
while n <= 10
do
	-- блок операторов, который будет
	-- выполняться многократно, пока n <= 10
	-- если n не будет изменяться, цикл никогда не закончится
	n = n + 1		-- например, так
end
}}}

====Цикл с пост-условием (repeat-until)====
{{{
local v = get_some_value()
repeat
	print(v)
	v = get_some_value()
until v == nil	-- закончить, когда v == nil
}}}

====Оператор break====
Для досрочного прекращения цикла используется оператор break:
{{{
while(true)				-- бесконечный цикл
do
	-- do something
	if (пора закругляться) then
		break			-- "досрочный" выход из цикла
	end
	-- do something else
end
}}}
Break работает с любыми видами циклов (while, repeat-until и for).

====Простой цикл for====
Для организации циклов со счетчиком используется "простой" оператор for:
{{{
-- вверх:
for v = 5,10,1			-- начальное значение, конечное значение, шаг
do
	print(v)		-- выведет в столбик: 5 6 7 8 9 10
end

-- и вниз:
for i = 8,2,-2			-- начальное значение, конечное значение, шаг
do
	print(i)		-- выведет в столбик: 8 6 4 2
end
}}}

Переменные v и i в данном примере являются ''локальными'' для соответствующих блоков do-end, образующих тела циклов, и снаружи блоков не доступны.

Параметры циклов (5,10,1 и 8,2,-2 в примере выше) могут быть как константами, так и выражениями (вычисляются один раз перед началом цикла):
{{{
local start, n = 100, 50
for v = start, start+n, n/5
do
	print(v)		-- выведет в столбик: 100;110;120;130;140 150
end
}}}

====Расширенный for====
Для перебора всех строк таблицы (что часто встречается) используется следующая запись цикла for:
{{{
local t = {			-- таблица компаний и их основателей
	["microsoft"] = "gates",
	["apple"] = "jobs",
	["google"] = "brin"
}
for k,v in pairs(t)		-- k – key, v - value
do
	print(k.." found by "..v)--> apple found by jobs
end				 --> microsoft found by gates
				 --> google found by brin
}}}

Порядок, в котором будет происходить перебор строк таблицы, спецификацией языка ''не определен''. Это значит, что на разных машинах, в разных версиях интерпретатора он может быть разным.

===Функции===
В отличие от традиционных компилируемых языков программирования, где список функций и их имен определяется раз и навсегда во время компиляции программы, Lua позволяет производить с функциями любые манипуляции (примерно те же, что и с таблицами) во время выполнения программы. Чтобы создать функцию, надо написать ее тело и присвоить его переменной-ссылке (переменная в данном случае будет иметь тип function):
{{{
max = function(a,b)
	if a > b then
		return a
	else
		return b
	end	-- конец if'а
end	-- конец тела функции
}}}

В данном примере определена функция с двумя параметрами (a и b) и возвращающая одно значение в качестве результата. Строки, заключенные между "function(a,b)" и последним "end" — это тело функции (операторы, которые, собственно, будут выполняться при ее вызове). Ссылка на функцию хранится в глобальной переменной max. Вызвать только что определенную функцию можно следующим образом:
{{{
local x,y = 3, 5
local m = max(x, y)	-- теперь m = 5
}}}

Можно дать функции альтернативное имя, создав еще одну ссылку на нее:
{{{
local find_maximum = max
}}}
И вызывать функцию через новую ссылку:
{{{
m = find_maximum(y, x)		-- m опять 5
}}}

Эта функциональность позволяет передавать функции в другие функции в качестве параметров и возвращать их с помощью return:
{{{
max = function(a,b)
	if a > b then
		return a
	else
		return b
	end
end

min = function(a,b)
	if a < b then
		return a
	else
		return b
	end
end

-- table – таблица, в которой искать
-- compare – функция, выбирающая одно значение из двух
function find(table, compare)
	local result = nil
	for k, v in pairs(table)
	do
		-- если функция выбрала v – запомнить его!
		if(compare(v, result) == v) then
			result = v
		end
	end
end

---- теперь найдем максимальное и минимальное значения ----
table = {7, 4, 1, 8, 5}
local max_value = find(table, max)	-- передать max как "функцию выбора"
local min_value = find(table, min)	-- передать min как "функцию выбора"
}}}

Аналогично можно вернуть ссылку на функцию как результат работы какой-либо другой функции:
{{{
make_func = function(name)
	-- локальная переменная – ссылка на функцию
	local max = function(a,b)
		if a > b then
			return a
		else
			return b
		end
	end

	-- локальная переменная – ссылка на функцию
	local min = function(a,b)
		if a < b then
			return a
		else
			return b
		end
	end

	-- теперь собственно код функции make_func:
	-- в зависимости от значения параметра name вернуть одну из двух
	-- определенных выше локальных функций
	if name == "max" then
		return max
	elseif name == "min" then
		return min
	else
		return nil
	end
end

---- теперь воспользуемся этим "конструктором функций" ----
local my_min = make_func("min")		-- получить ссылку на функцию
local x,y = 3, 5
local min = my_min(x, y)		-- min = 3
local max = make_func("max")(x,y)	-- max = 5
local my_aver = make_func("average")	-- ошибка! (make_func вернет nil)
}}}

====Внешние локальные переменные и замыкания функций====
Приведенный выше пример, помимо возврата функции из функции, демонстрирует еще одну важную концепцию — вложенные функции (функции max и min определены "внутри" функции make_func!). В языке Lua вложенные функции имеют доступ к локальным переменным того блока, в который они вложены." По отношению к этим функциям такие переменные называются "внешними локальными переменными". В функции make_func из примера выше эта возможность не используется (функции max и min абсолютно самостоятельны), но можно привести пример, где эта возможность существенно важна.

Например, определим следующий "конструктор функций":
{{{
-- функция, возвращающая функцию, предназначенную
-- для проверки попадания значения в заданный интервал
make_checker = function(low, hi)
	-- локальная переменная – ссылка на функцию
	local result = function(x)
		if low <= x and x <= hi then
			return true
		else
			return false
		end
	end

	-- возвращаем ссылку на определенную выше функцию
	return result
end

-- воспользуемся ей для создания нескольких checker'ов:
local temperature_ok = make_checker(0, 5)
local humidity_ok = make_checker(0, 75)

-- проверим наши условия на пригодность для хранения
-- продукта (от 0 до 5 градусов Цельсия и от 0 до 75% влажности)
local t, h = 5, 80
local store_ok = temperature_ok(t) and humidity_ok(h)

-- теперь store_ok = false, т.к. 80% – неподходящая влажность!
}}}

Время жизни локальных переменных, как известно, совпадает с временем выполнения функции (блока), в которой они определены (т.е. они создаются при вызове функции и уничтожаются при возврате из нее). В нашем же примере локальные переменные low и hi функции make_checker *не могут быть уничтожены* при возврате (return), потому что они *продолжают использоваться* (как внешние локальные переменные) из функции (result), которую make_checker возвращает! Поэтому в таких случаях *автоматически создаются копии* всех таких переменных и эти копии "привязываются" к использующей их (вложенной) функции. В результате — они по-прежнему доступны из нее как внешние локальные переменные. Совокупность таких копий называется *замыканием* (closure) соответствующей функции. В примере выше каждая из функций temperature_ok и humidity_ok имеет замыкание, состоящее из двух переменных: low и hi (всего — 4 шт.).

===Литература===
 # Справочное руководство по Lua (перевод на русский): http://www.lua.ru/doc/
 # Книга "Programming in Lua" 1st ed.: http://www.lua.org/pil/
 # Tutorial'ы: http://lua-users.org/wiki/TutorialDirectory
 # Примеры кода: http://lua-users.org/wiki/SampleCode