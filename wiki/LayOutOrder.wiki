#summary Что происходит, когда какой-то элемент меняет размер

== Общее описание ==
Сцена на экране представляет собой иерархию !CompositeItem'ов, в которых могут лежать также обычные Item'ы. Каждый элемент может попросить своего родителя обновить расположение. Это обновление будет происходить непосредственно перед прорисовкой очередного кадра.

Каждый !CompositeItem хранит два флага:
 * need_lay_out - значит надо перерасположить свои элементы;
 * need_lay_out_children - у меня все в порядке, но кто-то из контейнеров-потомокв хочет обновить свои внутренности (замечение: когда мы разрешим ему это сделать, он, возможно вырастет и попросит нас тоже обновиться).

Также !CompositeItem может получать сигналы на само обновление - один сверху и два снизу:
 * doLayOut() - вызывается "сверху" (родителем); в ответ на этот сигнал надо проверить свои флаги и, если они того требуют, обновить себя и потомков;
 * requestLayOut() - вызывают дочерние элементы, когда меняют свой размер; в ответ на этот вызов контейнер устанавливает need_lay_out=true, а всем своим предкам, вплоть до root'а, говорит need_lay_out_children=true;
 * requestLayOutChildren() - вызывается композитным элементом для своего родителя, когда этот элемент установил себе флаг need_lay_out_children и сам при этом не находится в цикле обовления расположения потомков. В ответ на этот сигнал элемент проверят, не находится ли он в цикле обновления потомков, и если нет - устанавливает флаг need_lay_out_children.

== Порядок действий ==
Предположим, что некоторый элемент-надпись поменял свой текст и, как следствие, размер. Дальше будет происходить следующее:
 # Надпись вызовет requestLayOut() у родителя.
 # Родитель взведет себе флаг need_lay_out, а всем своим предкам - need_lay_out_children.
 # Далее, перед прорисовкой кадра, система вызовет doLayOut() для корневого элемента.
 # Корневой элемент увидит у себя флаг need_lay_out_children и вызовет doLayOut() всем своим дочерним элементам. Те из них, у кого ни один из флагов не установлен, проигнорируют запрос. У кого need_lay_out_children - спустят запрос вниз по иерархии.
 # Допустим, запрос дошел до "дедушки" нашей надписи. Так как у него need_lay_out_children, дедушка передает запрос "отцу". Сам он ничего не перемещает, т.к. need_lay_out у него false.
 # "Отец" - передвигает сои дочерние элементы (внешняя функция onRequestLayOut), после чего снимает флаг need_lay_out и вызывает своим потомкам-контейнерам doLayOut() (т.к. они могли поменять свой размер). Затем - assert(need_lay_out == false).
 # В процессе расстановки дочерних наш элемент мог и сам поменять размер. В таком случае он скажет дедушке requestLayOut().
 # Дедушка, закончив вызывать doLayOut() у потомков, снимает у себя флаг need_lay_out_children и вдруг обнаруживает, что взведен флаг need_lay_out - кто-то из дочерних элементов только что поменял размер. Тогда он также обновляет расположение элементов (onRequestLayOut) и снимает флаг need_lay_out. Затем - опять рекурсивный вызов doLayOut() (потомки могли поменять размер) и assert(need_lay_out == false) и если мы выросли - сказать requestLayOut() родителю.

UPD В onRequestLayOut нельзя сбрасывать флаг need_lay_out, потому что растянутные только что элементы могли поменять свою вторую размерность, и надо повторить перерасположение.