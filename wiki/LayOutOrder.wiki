#summary Что происходит, когда какой-то элемент меняет размер

<wiki:gadget url="http://markmail.org/gadgets/markmailmini.xqy?l=olymp_csd&r=all" />

== Общее описание ==
Сцена на экране представляет собой иерархию !CompositeItem'ов, в которых могут лежать также обычные Item'ы. Каждый элемент может попросить своего родителя обновить расположение. Это обновление будет происходить непосредственно перед прорисовкой очередного кадра.

Каждый !CompositeItem хранит два флага:
 * need_lay_out - значит надо перерасположить свои элементы;
 * need_lay_out_children - у меня все в порядке, но кто-то из контейнеров-потомокв хочет обновить свои внутренности (замечение: когда мы разрешим ему это сделать, он, возможно вырастет и попросит нас тоже обновиться).

Также !CompositeItem может получать сигналы на само обновление - один сверху и два снизу:
 * doLayOut() - вызывается "сверху" (родителем); в ответ на этот сигнал надо проверить свои флаги и, если они того требуют, обновить себя и потомков;
 * requestLayOut() - вызывают дочерние элементы, когда меняют свой размер; в ответ на этот вызов контейнер устанавливает need_lay_out=true, а всем своим предкам, вплоть до root'а, говорит need_lay_out_children=true;
 * requestLayOutChildren() - вызывается композитным элементом для своего родителя, когда этот элемент установил себе флаг need_lay_out_children и сам при этом не находится в цикле обовления расположения потомков. В ответ на этот сигнал элемент проверят, не находится ли он в цикле обновления потомков, и если нет - устанавливает флаг need_lay_out_children.

== Порядок действий ==
Предположим, что некоторый элемент-надпись поменял свой текст и, как следствие, размер. Дальше будет происходить следующее:
 # Надпись вызовет requestLayOut() у родителя.
 # Родитель взведет себе флаг need_lay_out, а всем своим предкам - need_lay_out_children.
 # Далее, перед прорисовкой кадра, система вызовет doLayOut() для корневого элемента.
 # Корневой элемент увидит у себя флаг need_lay_out_children и вызовет doLayOut() всем своим дочерним элементам. Те из них, у кого ни один из флагов не установлен, проигнорируют запрос. У кого need_lay_out_children - спустят запрос вниз по иерархии.
 # Допустим, запрос дошел до "дедушки" нашей надписи. Так как у него need_lay_out_children, дедушка передает запрос "отцу". Сам он ничего не перемещает, т.к. need_lay_out у него false.
 # "Отец" - передвигает сои дочерние элементы (внешняя функция onRequestLayOut), после чего снимает флаг need_lay_out и вызывает своим потомкам-контейнерам doLayOut() (т.к. они могли поменять свой размер). Затем - assert(need_lay_out == false).
 # В процессе расстановки дочерних наш элемент мог и сам поменять размер. В таком случае он скажет дедушке requestLayOut().
 # Дедушка, закончив вызывать doLayOut() у потомков, снимает у себя флаг need_lay_out_children и вдруг обнаруживает, что взведен флаг need_lay_out - кто-то из дочерних элементов только что поменял размер. Тогда он также обновляет расположение элементов (onRequestLayOut) и снимает флаг need_lay_out. Затем - опять рекурсивный вызов doLayOut() (потомки могли поменять размер) и assert(need_lay_out == false) и если мы выросли - сказать requestLayOut() родителю.

UPD В onRequestLayOut нельзя сбрасывать флаг need_lay_out, потому что растянутные только что элементы могли поменять свою вторую размерность, и надо повторить перерасположение.

UPD2 Если из двух связанных параметров один явно не фиксируется и берется из текущего значения, а второй - задается родительским контейнером, то с точки зрения Cassowary они равноправны (ClsWeak), и когда родитель захочет поменять значение контролируемого им параметра - то Cassowary может ему этого не дать сделать, т.к. его "держит" второй. Выход - сделал тяжесть связи 2.0 при Edit'е параметра.

UPD3 Если сначала сделать link, а потом изменить какой-то параметр - то первый же solve() вернет все обратно. Поэтому в !LuaCassowary::solve() даже при первом вызове теперь происходит только обновление измененных полей. Чтобы это не сужало до нуля всю сцену из-за привязанного к сцене "description" нулевой ширины (при первом же Edit'е фиксируется значение 0 с весом 2.0) - теперь в функции link предварительное "наивноя" выставление начальных значений параметров (см. adkust_link в lib.lua).

UPD4 Все параметры - зависимые и независимые - устанавливаются в Stay Weak. Для координат strength=1.0, для размеров - 1.5. Независимые - на 0.1 больше. У всех Edit'ов strength=2.0. Перед началом solve() делается GetExternalValues(), но это еще под вопросом.

UPD5 Если приклеить друг к другу 2 элемента, то движок может начать двигать любой из них (т.к. у обоих есть stay). Вывод - независимого надо ставить "крепче".

UPD6 Если к элементу с высотой, заданной просто в коде, снизу приклеить еще какую-то конструкцию, и в этой конструкции будут элементы, которые меняют свою высоту - то они могут "задавить" наш элемент. Вывод: всегда помнить, что связи симметричны и в них нет "зависимого" и "зависящего", и что-то с этим делать. Как-то помечать элементы, которые сами определяют свои размеры?!

UPD7 Когда дочерний элемент сопротивляется изменению своего размера - он должен сказать родительскому requestLayOut - иначе тот будет думать, что изменение размера прошло успешно.