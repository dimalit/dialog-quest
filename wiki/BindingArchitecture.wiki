#summary Архитектура C++-классов, экспортируемых в Lua, и как их туда экспортировать

= Общие принципы =
 * Все C++-классы, экспортируемые в Lua, должны исправно и самостоятельно работать в C++ (на случай отказа то Lua или замены ее на другой язык).
 * Для каждого экспортируемого класса !SomeClass создается открытый наследник с именем !LuaSomeClass. В нем прописываются некоторые специфичные для Lua свойства, поля и методы (см. !LuaScreenItem). Этот клас описыавется либо в той же паре .h+.cpp файлов, либо в отдельной, если класс получился достаточно большой.
 * Если исходные C++-классы соединены отношением наследования, то их Lua- потомки также наследуют друг друга. Это может привести к проблеме виртуального наследования (см. !LuaScreenItem).
 * В классе !LuaSomeClass создается статический метод luabind(lua_State{{{*}}} L), который, собственно, осуществляет регистрацию в Lua данного класса. Биндинг осуществляется как тут: http://www.rasterbar.com/products/luabind/docs.html#binding-classes-to-lua . Методы luabind() из всех Lua-классов вызываются в функции App::Init() при старте программы (см. App.cpp).


= Какие файлы смотреть =
 * !ScreenItem.h/!ScreenItem.cpp содержат классы !ScreenItem, !SimpleItem и !CompositeItem.
 * !LuaScreenItem.h/!LuaScreenItem.cpp содержит соответствующие всем трем видам !ScreenItem'ов Lua-классы и их методы luabind (см.!)
 * Image.h/Image.cpp, Animation.h/Animation.cpp, Texture.h/Texture.cpp содержат соответствующие "View-" классы и их Lua-варианты. Все они наследуются от Proton'овского класса !EntityComponent (зачастую косвенно). Эти классы могут быть переданы в метод setView() класса !SimpleItem (чтобы назначить тому внешний вид).
 * Timer.h/Timer.cpp, LuaTimer.h/LuaTimer.cpp - то же для класса Timer. Класс !LuaTimer интересен тем, что для хранения ссылки на callback-функцию (которая будет вызываться при срабатывании таймера) использует класс luabind::object, а также экспортирует это поле в Lua и умеет вызывать его как функцию.
 * Text.h/Text.cpp - реализует все классы, связанные с отображением текста: Text и TextBox (а также LuaText и LuaTextBox).

= !LuaScreenItem =
Так как все, что мы видим на экране - это разновидности ScreenItem'ов, рассмотрим иерархию классов-наследников ScreenItem'а более подробно. См. рисунок.

https://dialog-quest.googlecode.com/svn/wiki/classes_lua.png

Как видим, на рисунке:
 * !ScreenItem и две его разновидности - SimpleItem и CompositeItem - образуют иерархию "штаны".
 * К этм "штанам" подключается еще одна точно такая же иерархия из !LuaScreenItem и его потомков.
 * В результате возникает ситуация множественного наследования (!ScreenItem наследуется в !LuaSimpleItem и LuaCompositeItem двумя путями). Поэтому на уровне непосредственных наслеников !ScreenItem'а применено [http://habrahabr.ru/post/185826/ виртуальное наследование].

= Другое =
 * В методе luabind класса !LuaCompositeItem в Lua-машину добавляется глобальная переменная под именем root - корень дерева всех экранных элементов. См. функцию root_item() в LuaScreenItem.cpp.
 * В файле lua_lib.cpp оисаны несколько экспортируемых в Lua свободных функций и переменных: screen_width, screen_height, rand() и др.